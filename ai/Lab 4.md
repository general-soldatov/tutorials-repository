# LAB 4 "РАЗРАБОТКА ЧАТ-БОТА НА ОСНОВЕ МАШИННОГО ОБУЧЕНИЯ"

## Target
освоить навыки разработки чат-бота, способного отвечать на вопросы пользователей по заранее заданной тематике.

## Theory
В рамках метода проектного обучения результатом освоения дисциплины становится созданный обучающимся чат-бот, способный отвечать на вопросы пользователей по заданной тематике.   
Чат-бот – это программа, использующая технологии искусственного интеллекта, которая имитирует общение с человеком и может мгновенно реагировать на пользовательские запросы.  
Проект, разработанный обучающимся, может найти практическое применение в учебной деятельности, например, при защите курсовых работ, отчетов по практике, а также при организации студенческих конференций и научных семинаров.  
Реализация итогового проекта начинается с четвёртой лабораторной работы, в которой обучающиеся разрабатывают чат-боты на основе алгоритмов классификации, и продолжается в следующих лабораторных работах.
JSON (JavaScript Object Notation) – текстовый формат, предназначенный для обмена данными между программами. Он похож на словари и списки Python, но записывается как обычный текст.  
Объекты JSON представляют собой пары «ключ – значение» и заключаются в фигурные скобки {}.
Ключи могут быть только строками, значения – различными типами данных.
Если ключ имеет несколько значений, они записываются в квадратные скобки [] через запятую.
```py
students = {
"Студенты": ["Иванов", "Петров", "Сидоров"]
}
```
В указанном примере «Студенты» – это ключ, а их фамилии («Петров», «Иванов») – это значения, которые принимает ключ.  
Массив – это упорядоченный набор элементов, каждый из которых имеет свой уникальный номер (индекс), позволяющий быстро получить к нему доступ. Нумерация элементов в массиве начинается с 0.

## Practics
Создайте новый блокнот в Google Colab, добавьте текстовую ячейку и впишите следующий текст: «Лабораторная работа студента группы … Фамилия Имя», указав свой номер группы, фамилию и имя.
Создайте	JSON-файл	с	использованием	JSON	Editor	Online (https://jsoneditoronline.org) или другого редактора.  
В левой части редактора JSON Editor Online наберите необходимый текст и трансформируйте (Transform) его в файл JSON.
```json
{
"Студенты": {
"Фамилия": {
"Вопрос": [
"Ваша фамилия?", "Как Вас зовут?",
"Представьтесь, пожалуйста."
],
"Ответ": ["Иванов", "Петров", "Сидоров"]
},
"Дисциплины": { "Вопрос": [
"Какие дисциплины Вы изучаете?", "Что Вам преподают?",
"Чему Вас учат?"
],
"Ответ": ["Математика", "История", "Физика"]
}
}
}
```
Одна из фамилий должна совпадать с фамилией обучающегося, выполняющего лабораторную работу.
Обратите внимание, что у разных объектов («Фамилия», «Дисциплина») одинаковые ключи («Вопрос», «Ответ»), хотя значения ключей различны.
Сохраните файл JSON на Google Диск.
Подключите Google Диск. 
```py
from google.colab import drive
drive.mount('/content/drive')
```
Найдите файл JSON, скопируйте его путь и загрузите в Colab.
```py
file_path = '/content/drive/MyDrive/StudDis.json'
with open(file_path, 'r', encoding='utf-8') as file:
  data = file.read()
```
Данные в файле JSON записаны как обычный текст. Чтобы текст в файле json конвертировался в объекты, необходимо из библиотеки JSON загрузить функцию loads(), которая преобразует текст в объект (пара
«ключ – значение»).
Импортируйте библиотеку JSON и конвертируйте содержимое файла.
```py
import json
students_data = json.loads(data)
print(students_data)
```
Для загрузки объектов из файла JSON в массив можно воспользоваться методом append(). Этот метод добавляет элемент, переданный в качестве аргумента, в конец списка. Например, чтобы добавить элемент item в конец списка list, используйте код
```py
list.append(item)
```
Загрузите в массив X вопросы (слова и словосочетания), представляющие собой значения ключа «Вопрос», а в массив y – метки, соответствующие значениям ключа «Студенты».
```py
X, y = [], []
for key, value in students_data['Студенты'].items():
  for question in value['Вопрос']:
    X.append(question)
    y.append(key)

X, y
```
В приведенном примере пользователь может интересоваться либо фамилиями обучающихся, либо изучаемыми ими дисциплинами. В результате каждому вопросу будет присвоена метка «Фамилия» или «Дисциплины».
Чтобы загрузить вопросы пользователя из файла json в массив X, а соответствующие метки – в массив y, используется циклическая конструкция.  
В результате в массивы X и y были успешно загружены вопросы и соответствующие им метки, которые будут использованы для обучения модели. Процесс обучения сводится к решению задачи классификации, где обученная модель сможет определять метку для заданного вопроса пользователя и, основываясь на этой метке, выбирать адекватный ответ. 
Работа с текстом – одно из ключевых направлений применения алгоритмов машинного обучения. Но дело в том, что текстовые данные не могут быть напрямую переданы в алгоритмы машинного обучения, так как они работают только с числовыми векторами фиксированного размера, а тексты имеют переменную длину.  
Поэтому, прежде чем использовать массив X для машинного обучения, необходимо преобразовать содержащиеся в нем слова и фразы в числовые векторы.  
Для этого можно воспользоваться модулем sklearn.feature_extraction.text из библиотеки sklearn. Он содержит функции, которые позволяют преобразовывать текстовые данные в формат, совместимый с алгоритмами машинного обучения.
Одной из таких функций является CountVectorizer(). Она выполняет следующие задачи:  
*	разделяет текст на отдельные слова (токенизация), используя пробелы и знаки препинания в качестве разделителей токенов;  
*	подсчитывает количество уникальных слов в каждом документе. При этом положение слов в тексте не учитывается.
 
Используйте модуль CountVectorizer из библиотеки sklearn:
```py
import sklearn
from sklearn.feature_extraction.text import CountVectorizer

# преобразуем текст в числовой вектор
students_vectorizer = CountVectorizer()
students_m = students_vectorizer.fit_transform(X)
students_m.toarray()
```
Выберите метод классификации RandomForestClassifier() из модуля sklearn.ensemble.
Основой метода RandomForestClassifier() является другой метод – деревья решений (decision trees).
Метод деревьев решений работает следующим образом: в каждом узле проверяется определенный признак объекта. На основе проверки выполняется переход по соответствующей ветке. Процесс повторяется до тех пор, пока не будет достигнут лист, содержащий информацию о принадлежности объекта к определенному классу.  
Ниже представлен пример классификации потенциальных заемщиков на два класса: «Клиенты, которым банк одобрил кредит» и «Клиенты, которым банк не одобрил кредит».
![image](https://github.com/user-attachments/assets/60ef29ec-69dd-4c5c-ad3c-efbc078a15ef)

В методе RandomForestClassifier() базовые модели представляют собой деревья решений (decision trees), которые обучаются на данных, сформированных из случайных подмножеств исходной обучающей выборки. Для повышения точности классификации предсказания этих моделей усредняются.  
Импортируйте и настройте метод классификации RandomForestClassifier:
```py
# загрузка метода классификации RandomForestClassifier() и обучение модели классификации текста

from sklearn.ensemble import RandomForestClassifier

students_RandomFCI = RandomForestClassifier()
students_RandomFCI.fit(students_m, y)
```
Проверьте работу модели, задав произвольный вопрос. Для этого введите произвольный вопрос о фамилиях обучающихся (например, «Как фамилия студента?») или об изучаемых ими дисциплинах (например, «Какие дисциплины вы изучаете?»). Преобразуйте текст вопроса в числовой вектор и проверьте, правильно ли модель присвоила ему метку («Фамилия» или «Дисциплины»), используя функцию predict.
```py
# проверим качество модели

text = input()
test = students_vectorizer.transform([text])
question = students_RandomFCI.predict(test)[0]
print('Question label:', question)
```
Создайте функцию для получения ответа. Так как ответ генерируется случайным образом из множества возможных вариантов, соответствующих указанному намерению, необходимо предварительно импортировать модуль библиотеки random.
```py
# создадим функцию, генерирующую ответ пользователю

import random

def get_answer(question):
  responses = students_data['Студенты'][question]['Ответ']
  return random.choice(responses)

answer = get_answer(question)
print('Answer:', answer)
```



