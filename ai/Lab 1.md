# LAB 1 "РАЗРАБОТКА МОДЕЛИ МАШИННОГО ОБУЧЕНИЯ ДЛЯ РЕШЕНИЯ ЗАДАЧИ КЛАССИФИКАЦИИ С ИСПОЛЬЗОВАНИЕМ БИБЛИОТЕК, МОДУЛЕЙ И ФРЕЙМВОРКОВ PYTHON"

## Target
Решение задачи классификации объектов на примере цветков ириса и бутылок вина с помощью программного кода, написанного на языке Python в блокнотах на платформе Google Colab.

## Theory

Jupyter Notebook – это среда для разработки и выполнения программного кода и его отдельных фрагментов. Она работает офлайн.
Google Colab (далее Colab) – облачный сервис, который позволяет использовать файлы Jupyter Notebook без их установки на локальный компьютер.  
Файлы, созданные в Jupyter Notebook или Colab, имеют расширение .ipynb и называются блокнотами (тетрадями, ноутбуками). В них можно писать код на различных языках программирования, однако для задач искусственного интеллекта чаще всего используется Python. Популярность Python обусловлена наличием множества библиотек и фреймворков для работы с искусственным интеллектом и машинным обучением.  
Блокноты Colab хранятся в облаке Google Диск, в папке Colab Notebooks, которая создается автоматически. Для работы в Colab требуется аккаунт Google.  
Рассмотрим подробно решение задачи классификации ирисов с использованием машинного обучения и программного кода на языке Python.

## Practics
Для создания модели потребуются модули, фреймворки и датасеты библиотеки scikit-learn (версия 1.2.2).
Перейдите на сайт Google Colab (https://colab.research.google.com/) и выберите опцию New Notebook (Создать новый блокнот).
Войдите в аккаунт Google.  
В блокноте информация размещается в ячейках, которые бывают двух типов: кодовые и текстовые. Текстовые ячейки используются для написания пояснений к программному коду, отображения изображений, видео и т. д. Кодовые ячейки используются для написания и выполнения программного кода.  
Чтобы добавить кодовую или текстовую ячейку в Colab, нужно выбрать соответствующий пункт в меню «Вставка» или подвести указатель мыши к середине нижней границы ячейки и выбрать одну из кнопок:  
`«+ Код»` или `«+ Текст»`.  
В блокноте создайте текстовую ячейку, в ней напишите текст без кавычек: «Лабораторная работа студента группы … Фамилия, имя», указав свои данные: номер группы, фамилию и имя.  
Далее создадим кодовые ячейки, в которые введем программный код. Также в кодовых ячейках мы будем указывать комментарии к программному коду. Они начинаются с символа #.  
После ввода программного кода необходимо запускать его для получения результата. Установите пакет scikit-learn. Если библиотека уже установлена, этот шаг можно пропустить.  
После ввода программного кода необходимо запускать его для получения результата.  
Установите пакет scikit-learn. Если библиотека уже установлена, этот шаг можно пропустить.
```python
# загружаем библиотеку scikit-learn
!pip install scikit-learn
```
Установите библиотеку sklearn, а также различные модули, необходимые для работы.
```python
# импортируем библиотеки и модули
import sklearn
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
```
Загрузите набор данных load_iris из модуля datasets библиотеки sklearn.
```py
# загружаем датасет load_iris
iris_dataset = load_iris()
```
Просмотрите описание набора данных.
```py
# получим информацию о датасете
load_iris print(iris_dataset.DESCR)
```
Датасет содержит информацию о 150 цветках ириса. Каждый цветок характеризуется четырьмя параметрами:
*	длина чашелистика в сантиметрах (sepal length);
*	ширина чашелистика в сантиметрах (sepal width);
*	длина лепестка в сантиметрах (petal length);
*	ширина лепестка в сантиметрах (petal width).
  
Все цветки ириса подразделяются на 3 класса:
*	setosa;
*	versicolour;
* virginica.
Выведите на экран параметры цветков ириса.
```py
# выведем набор данных с параметрами цветков ириса
print(iris_dataset.data)
```
Каждый столбец набора данных характеризует тот или иной параметр цветка ириса: длина чашелистика, ширина чашелистика, длина лепестка, ширина лепестка.  
Каждая строка набора данных – это информация о параметрах одного цветка ириса.  
Отобразите метки классов. 
```py
# выведем метки цветков ириса
print(iris_dataset.target)
```
Метка показывает, к какому классу относится тот или иной цветок ириса. Все цветки распределены по трем классам. Метка «0» означает, что цветок ириса относится к классу «setosa», метка «1» – к классу «versicolour», метка «2» – к классу «virginica».  
Обратите внимание на то, что цветки ириса выстроены в датасете в строгом порядке: в начале списка идут цветки с меткой «0» (класс «setosa»), вторыми перечислены цветки с меткой «1» (класс «versicolour»), третьи в списке – цветки с меткой «2» (класс «virginica»).  
Процесс построения модели разбивается на два основных этапа:  
*	этап обучения модели;  
*	этап тестирования модели (проверка ее надежности).
    
Соответственно, набор данных о цветках ириса нужно разбить на два подмножества. Большее по количеству объектов подмножество используется для обучения модели. На меньшем подмножестве осуществляется проверка качества обучения модели.  
Разобьем датасет с данными о цветках ириса на обучающую и тестируемую выборки. Обозначим набор данных обучающей выборки следующим образом: данные с характеристиками цветков ириса – X_train, соответствующие им метки – y_train. Набор данных тестируемой выборки обозначим так: данные с характеристиками цветков ириса – X_test, соответствующие им метки – y_test.  
Для разбиения датасета в библиотеке scikit-learn есть функция train_test_split(X, y, train_size = k, random_state = 10), где X – данные с характеристиками объектов, y – метки объектов, k – доля датасета, которую нужно включить в обучающую выборку.  
Одновременно функция train_test_split(X, y, train_size = k, random_state = 10) перемешивает набор данных в датасете.  
Разделите набор данных с использованием функции train_test_split, значение переменной variant_number должно быть равно номеру вашего варианта.
```py
# разбиваем датасет на обучающую и тестируемую выборку
variant_number = 15 # номер варианта
k = 1 - ((variant_number + 10) / 100) # пропорция обучающей выборки
X_train, X_test, y_train, y_test = train_test_split(
  iris_dataset.data, iris_dataset.target, train_size=k, random_state=10
)
```
Проверьте размеры обучающей и тестовой выборок.
```py
# Проверяем размер выборок
print(f"Размер обучающей выборки: {len(X_train)}, {len(y_train)}")
print(f"Размер тестовой выборки: {len(X_test)}, {len(y_test)}")
```
Обучим разрабатываемую модель для решения задачи классификации объектов с помощью трех алгоритмов классификации: kNN (метод k- ближайших соседей), Logistic Regression (метод логистической регрессии), Random Forest (метод случайных деревьев).  
Самый простой из перечисленных методов классификации – это метод k-ближайших соседей. В соответствии с данным методом объект (цветок ириса) относится к тому классу, который наиболее распространен среди k-соседей данного объекта, классы которых уже известны.
Метод логистической регрессии является методом классификации, в соответствии с которым определяется вероятность отнесения исходного значения к тому или иному классу.  
Результатом использования логистической регрессии является построение n-мерной разделительной плоскости, разделяющей пространство исходных значений на классы.  
Предположим, что множество исходных чисел состоит из двух классов: положительных и отрицательных чисел.
Если логистическая функция принимает значение от 0,5 до 1, то исходное число относится к классу положительных чисел. Если функция принимает значение от 0 до 0,5, то исходное число относится к классу отрицательных чисел.
![image](https://github.com/user-attachments/assets/4d940eba-e2a5-4378-bfa3-aef67b464d5d)
Загрузите алгоритмы классификации kNN, Logistic Regression, Random Forest в новую кодовую ячейку. Количество ближайших соседей n в алгоритме классификации kNN установите равным 5.
```py
# инициализируем классификаторы
knn = KNeighborsClassifier(n_neighbors=5)
logreg = LogisticRegression(max_iter=1000)
ranfor = RandomForestClassifier()
```
Обучите модели на обучающей выборке.
Для обучения моделей воспользуйтесь функцией fit из библиотеки sklearn. Данная функция подает на входной слой нейросети данные о характеристиках объектов из обучающей выборки (параметры цветков ириса), а на выходной – метки данных объектов (классы цветков ириса). Обучение модели заключается в установлении таких параметров нейросети, которые обеспечивают соответствие между характеристиками объектов и их метками.
```py
# обучаем модели
knn.fit(X_train, y_train)
logreg.fit(X_train, y_train)
ranfor.fit(X_train, y_train)
# делаем предсказания
y_knn = knn.predict(X_test)
y_logreg = logreg.predict(X_test)
y_ranfor = ranfor.predict(X_test)
# выводим результаты
print("Фактические метки:", y_test)
print("kNN:", y_knn)
print("Logistic Regression:", y_logreg)
print("Random Forest:", y_ranfor)
```
Оцените качество моделей с помощью функции score. Данная функция сравнивает метки, предсказанные моделью для объектов тестовой выборки, с фактическим метками данных объектов и рассчитывает долю правильно предсказанных меток. Максимальное значение показателя score равно 1. Это означает, что все метки для объектов тестовой выборки предсказаны правильно.  
Метрика score считает долю правильно предсказанных объектов, а для более точной оценки лучше использовать метрики precision, recall, F1-score.
```py
print(f"""kNN score: {knn.score(X_test, y_test)}
LogReg score: {logreg.score(X_test, y_test)}
RanFor score: {ranfor.score(X_test, y_test)}
""")
```
![image](https://github.com/user-attachments/assets/3afb8292-2a78-4eee-aef6-bff959fa80bf)
Создайте данные для новых объектов и выполните их классификацию.  
Так как каждый цветок ириса характеризуется четырьмя параметрами, то для каждого цветка укажите 4 числа.  
Для первого цветка первое число должно совпадать с порядковым номером дня из даты рождения обучающегося. Для второго цветка первое число должно совпадать с порядковым номером месяца из даты рождения обучающегося.
```py
day = 19
month = 2
X_new = [[day, 4, 3, 1], [month, 9, 3, 10]]

print(f"""kNN: {iris_dataset['target_names'][knn.predict(X_new)]}
LogReg: {iris_dataset['target_names'][logreg.predict(X_new)]}
RanFor: {iris_dataset['target_names'][ranfor.predict(X_new)]}
""")
```
![image](https://github.com/user-attachments/assets/a928fe7c-ace5-4780-8e4f-9cb020866b66)
Сохраните блокнот через меню «Файл / Сохранить».  
Переименуйте файл на Google Диске, используя шаблон «Лабораторная работа № 1 студента группы … Фамилия Имя», указав свой номер группы, фамилию и имя.


