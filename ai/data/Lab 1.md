# LAB 1 "ПЕРВИЧНЫЙ АНАЛИЗ ДАННЫХ"

## Target
изучение программных средств для визуализации наборов данных.

## Theory
Ядром pandas являются две структуры данных, в которых происходят все операции:  
* Series  
* Dataframes

Series − это структура, используемая для работы с последовательностью одномерных данных, а Dataframe − более сложная и подходит для нескольких измерений.
Пусть они и не являются универсальными для решения всех проблем, предоставляют отличный инструмент для большинства приложений. При этом их легко использовать, а множество более сложных структур можно упросить до одной из этих двух. Однако особенности этих структур основаны на одной черте − интеграции в их структуру объектов index и labels (метки). С их помощью структурами становится очень легко манипулировать.  
Series − это объект библиотеки pandas, спроектированный для представления одномерных структур данных, похожих на массивы, но с дополнительными возможностями. Его структура проста, ведь он состоит из двух связанных между собой массивов. Основной содержит данные (данные любого типа NumPy), а в дополнительном, index, хранятся метки.  
Для создания объекта Series с предыдущего изображения необходимо вызвать конструктор Series() и передать в качестве аргумента массив, содержащий значения, которые необходимо включить.
```py
s = pd.Series([12,-4,7,9])
s
```
Dataframe − это табличная структура данных, напоминающая таблицы из Microsoft Excel. Ее главная задача − позволить использовать многомерные Series. Dataframe состоит из упорядоченной коллекции колонок, каждая из которых содержит значение разных типов (числовое, строковое, булевое и так далее).  
В отличие от Series у которого есть массив индексов с метками, ассоциированных с каждым из элементов, Dataframe имеет сразу два таких. Первый ассоциирован со строками (рядами) и напоминает таковой из Series. Каждая метка ассоциирована со всеми значениями в ряду. Второй содержит метки для каждой из колонок. Dataframe можно воспринимать как dict, состоящий из Series, где ключи − названия колонок, а значения − объекты Series, которые формируют колонки самого объекта Dataframe. Наконец, все элементы в каждом объекте Series связаны в соответствии с массивом меток, называемым index.  
Простейший способ создания Dataframe − передать объект dict в конструктор DataFrame(). Объект dict содержит ключ для каждой колонки, которую требуется определить, а также массив значений для них.  
Если объект dict содержит больше данных, чем требуется, можно сделать выборку. Для этого в конструкторе Dataframe нужно определить последовательность колонок с помощью параметра column. Колонки будут созданы в заданном порядке вне зависимости от того, как они расположены в
объекте dict.  
```py
data = {'color' : ['blue', 'green', 'yellow', 'red', 'white'],
 'object' : ['ball', 'pen', 'pencil', 'paper', 'mug'],
 'price' : [1.2, 1.0, 0.6, 0.9, 1.7]}
frame = pd.DataFrame(data)
frame
```
## Practical
Выполним анализ набора данных «Предсказание ухода клиента». Данный набор данных используется в качестве учебного набора при изучении методов прогнозирования. Набор представляет собой данные об активности клиентаов телекоммуникационной компании (количество часов разговоров, видеозвонков, ночные и дневные разговоры и прочие). Набор данных подходит для обучения моделей логистической регрессии, моделей классификации (CNN, kNN, Logic tree). Набор данных можно получить в репозитории https://gist.github.com/106e92c7611cb8c4f99bde8d421d8477.git.  
Клонируем репозиторий в среду Google Colab командой:
```bash
!git clone https://gist.github.com/106e92c7611cb8c4f99bde8d421d8477.git
```
Рассмотрим основные признаки, представленные в наборе. Загрузим набор данных с использованием pandas и выведем признаки набора данных  
```py
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
import seaborn as sns
%matplotlib inline

data_path = "106e92c7611cb8c4f99bde8d421d8477/telecom_churn.csv"
df = pd.read_csv(data_path)
df.head()
```
Набор данных telecom_churn.csv содержит большое количество признаков. Для детального изучения воспользуемся методом info() класса DataFrame:
```py
df.info()
```
Графики, используемые при анализе данных, делят не по библиотекам, с использованием которых они строятся, а по типам признаков, для анализа которых предназначены графики.  
Для представления распределения простого количественного признака подходит обычная гистограмма, содержащаяся во всех библиотеках 
```py
df['Total day minutes'].hist();
```
<img width="552" height="413" alt="image" src="https://github.com/user-attachments/assets/45296e8f-7c33-454d-811a-61d15d4e06a6" />

Для построения гистограммы вызывается метод hist() класса DataFtrame. На самом деле используется метод из библиотеки matplotlib. Метод hist() можно использовать для построения гистограмм по нескольким признакам. При этом неколичественные признаки игнорируются.  
<img width="854" height="836" alt="image" src="https://github.com/user-attachments/assets/6e4f7864-4936-4876-add1-d170e85dbab5" />

Аналогичный тип графика можно получить с использованием matplotlib. Если необходимо построить аналогичный график распределения, то нужно выполнить
дополнительные расчеты.  
```py
plt.bar(df.index, df['Total day minutes'])
plt.show()
```
<img width="552" height="413" alt="image" src="https://github.com/user-attachments/assets/f6ba6bda-6b38-477b-a2a5-8ac85fa28529" />

```py
hist = df['Total day minutes'].value_counts()
plt.bar(hist.index, hist);
```
<img width="534" height="413" alt="image" src="https://github.com/user-attachments/assets/863a17cd-a12b-4241-b936-b3671d4473b9" />

Один из эффективных типов графиков для анализа количественных признаков – это «ящик с усами» (boxplot). 
```py
sns.boxplot(df['Total day minutes']);
```
<img width="571" height="394" alt="image" src="https://github.com/user-attachments/assets/2126fc2b-c688-4b91-8d8f-5f7274155b40" />

Для анализа нескольких признаков графики boxplot также эффективны. Ниже представлен код и результат построения графиков для анализа пяти штатов с максимальным объемом дневных звонков.
```py
top_data = df[['State', 'Total day minutes']]
top_data = top_data.groupby('State').sum()
top_data = top_data.sort_values('Total day minutes', ascending=False)
top_data = top_data[:7].index.values
sns.boxplot(y='State',
            x='Total day minutes',
            data=df[df.State.isin(top_data)], palette='Set3');
```
<img width="568" height="432" alt="image" src="https://github.com/user-attachments/assets/c40bc4b1-b6e6-41eb-83e8-493d7290492d" />

График boxplot состоит из коробки, усов и точек. Коробка показывает интерквартильный размах распределения, то есть соответственно 25% (первый квартиль, 𝑄1) и 75% (𝑄3) перцентили. Черта внутри коробки обозначает медиану распределения (можно получить с использованием метода median() в pandas и numpy). Усы отображают весь разброс точек кроме выбросов, то есть минимальные и максимальные значения, которые попадают в промежуток (𝑄1 − 1,5 ∙ 𝐼𝑄𝑅, 𝑄3 + 1,5 ∙ 𝐼𝑄𝑅), где 𝐼𝑄𝑅 = 𝑄3 − 𝑄1 – интерквартильный размах. Точками на графике обозначаются выбросы (outliers), то есть те значения, которые не вписываются в промежуток значений, заданный усами графика.  
Типичным категориальным признаком в анализируемом наборе данных является «Штат» (State). Под категориальный признак подходит также «Отказ» (Churn) (хотя он является логическим). Ниже представлены графики типа countplot() из библиотеки seaborn, которые строят гистограммы, но не по сырым данным, а по расчитанному количеству разных значений признака.
```py
sns.countplot(data=df['International plan'], palette='Set2')
```
<img width="567" height="432" alt="image" src="https://github.com/user-attachments/assets/3c07d0d7-76a7-4e51-a579-9ed485028bf4" />

```py
sns.countplot(df[df['State'].isin(df['State'].value_counts().head(5).index)]['State'], palette='Set1');
```
<img width="568" height="432" alt="image" src="https://github.com/user-attachments/assets/62425e20-c633-4867-bcdc-e1e86c4b4163" />

Одним из вариантов визуализации соотношения количественных признаков является диаграмма по нескольким признакам. Рассмотрим пример демонстрирующий сравнение распределений показателей, связанных с финансовыми затратами клиентов. Упрощенно, можно сказать, что это все показатели, содержащие подстроку «charge» в имени показателя. Ниже представлен код для отбора требуемых показателей.
```py
feats = [f for f in df.columns if 'charge' in f]
feats
```
После отбора интересующих показателей можно построить диаграммы для сравнения:
```py
df[feats].hist(figsize=(5, 5));
```
<img width="443" height="451" alt="image" src="https://github.com/user-attachments/assets/57d48bf4-616e-417e-b670-6bcd01726d77" />

Часто используют попарное сравнение признаков для обеспечения широкого взгляда на набор данных. На диагональных графиках ниже представлены гистограммы распределения отдельного признака, на внедиаганальных позициях – попарные распределения.  
```py
sns.pairplot(df[feats]);
```
<img width="986" height="986" alt="image" src="https://github.com/user-attachments/assets/f64f4aa1-eefb-4907-a888-0ee909a1e487" />

Можно реализовать более сложные графики. Например, если требуется добавить к существующим признакам, целевой признак Churn (количество отказов) и раскрасить разные типы элементов, то можно воспользоваться попарными распределениями, но с отображением подмножеств отказов.
```py
sns.pairplot(df[feats + ['Churn']], hue='Churn');
```
<img width="1080" height="986" alt="image" src="https://github.com/user-attachments/assets/06e58b7e-d7e8-472e-b8b7-d384ac26201f" />

До сих пор использовались возможности библиотеки seaborn, а также методы pandas (которые производят визуализацию, обращаясь к библиотеке matplotlib). Библиотека matplotlib наиболее известная и широко применяемая при анализе данных в рамках стека технологий python. Ниже показан пример использования графика scatter библиотеки matplotlib, предназначенного для вывода множества точек.
```py
plt.scatter(df['Total day charge'], 
            df['Total intl charge'],
            color='lightblue', edgecolor='blue')
plt.xlabel('Дневные начисления')
plt.ylabel('Международн. начисления')
plt.title('Распределение по 2 признакам')
plt.show()
```
<img width="554" height="455" alt="image" src="https://github.com/user-attachments/assets/181696c6-1518-4522-ab9c-101e5c162aad" />

Ниже показан пример более тонкой настройки параметров графика.
```py
c = df['Churn'].map({False: 'lightblue', True: 'orange'})
edge_c = df['Churn'].map({False: 'blue', True: 'red'})

plt.scatter(df['Total day charge'], df['Total intl charge'],
            color=c, edgecolors=edge_c)
plt.xlabel('Дневные начисления')
plt.ylabel('Международн. начисления')
plt.show()
```
<img width="554" height="432" alt="image" src="https://github.com/user-attachments/assets/83979a21-8148-4169-aba3-415b64131035" />

Данный график можно построить различными способами, например, можно добавлять множества точек отдельными подмножествами, указывая параметры визуализации для каждого подмножества:
```py
data_churn = df[df['Churn']]
data_loyal = df[~df['Churn']]

plt.scatter(data_churn['Total day charge'],
            data_churn['Total intl charge'],
            color='orange',
            edgecolors='red',
            label='Ушли')

plt.scatter(data_loyal['Total day charge'],
            data_loyal['Total intl charge'],
            color='lightblue',
            edgecolors='blue',
            label='Остались')
plt.xlabel('Дневные начисления')
plt.ylabel('Международн. начисления')
plt.title('Распределение клиентов')
plt.show()
```
<img width="554" height="455" alt="image" src="https://github.com/user-attachments/assets/bb73f0fb-66cc-416d-98f6-ba872768cb59" />

В реальных задачах машинного обучения при первичном анализе данных необходимо выявить корреляции признаков обучающей выборки. В пакете Pandas имеется встроенный инструмент для этого – метод corr() класса DataFrame. Ниже показан фрагмент вывода этой функции:
```py
data = df.drop(['State', 'International plan',	'Voice mail plan'], axis=1)
data.corr()
```
<img width="828" height="542" alt="image" src="https://github.com/user-attachments/assets/bf2049bd-fed2-4794-8774-d66291e24102" />

Полученная матрица имеет размер 17 × 17. Это незначительный размер (в реальных задачах машинного обучения размеры матриц корреляции имеют порядки 106 − 1010 и более), но даже для матрицы рассматриваемого набора данных проанализировать корреляцию признаков вручную – трудоемкая задача. Например, можно использовать скрипты, для выделения больших коэффициентов корреляции. Но лучше использовать специальный тип графика – heatmap.
```py
sns.heatmap(data.corr(), cmap=plt.cm.Blues);
```
<img width="673" height="576" alt="image" src="https://github.com/user-attachments/assets/cb3a4959-7f9e-4a14-a6be-de37a6ba76cc" />

Коррелирующие признаки обычно удаляются и не рассматриваются в процессе обучения.
