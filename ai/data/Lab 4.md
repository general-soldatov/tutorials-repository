# LAB 4 "ОСНОВЫ ИСПОЛЬЗОВАНИЯ БИБЛИОТЕКИ PYTORCH"

## Target
изучение возможностей библиотеки PyTorch.

## Theory
В данной работе рассмотриваются основы фреймворка глубокого обучения PyTorch.  
Когда необходимо написать искусственную нейронную сеть, решающую определённую задачу, будь то какая-нибудь простая классификация чего-либо или обнаружение лиц людей на видео. Всё, конечно, всегда начинается со сбора данных, а уже потом реализуются модели и проводятся эксперименты.  
Однако специалисты быстро поняли, что писать свои нейронные сети каждый раз с нуля долго и трудозатратно, поэтому придумали так называемые фреймворки – модули, в которых есть функционал, с помощью которого можно быстро и просто решать типовые задачи, и уже с помощью этих средств писать решения к более сложным задачам.
Существует большое количество фремворков глубокого обучения. Разница между ними прежде всего в том, каков общий принцип вычислений. Например, в Caffe и Caffe2 вы пишете код, по сути, составляя его из готовых «кусочков», как в Lego, в TensorFlow и Theano вы сначала объявляете вычислительный граф, потом компилируете его и запускаете (sees.run()), в то время как в Torch и PyTorch вы пишете почти точно так же, как на NumPy, а граф вычислений создаётся только при запуске (то есть существует только во время выполнения, потом он «разрушается»). Keras позволяет как строить блоки, так и компилировать свой граф:

<img width="334" height="250" alt="image" src="https://github.com/user-attachments/assets/712ddd4d-60ce-4c46-af90-b391c401496b" />

## Синтаксис PyTorch
Особенности PyTorch:  
– динамический граф вычислений;  
– удобные модули torch.nn и torchvision для написания нейросеток с минимальными усилиями;  
– в некоторых задачах даже быстрее TensorFlow (но не во всех);  
– легко проводить вычисления на GPU.  
Для использования PyTorch необходимо импортировать модуль:
```py
import torch
```
Рассмотрим, как в PyTorch выполняются операции с векторами. Тензором называется многомерный вектор, то есть есть:
```py
import numpy as np

x = np.array([1, 2, 3]) # вектор = тензор размерности 1 (то есть (1,))
y = np.array([[1, 2, 3], [4, 5, 6]]) # - матрица = тензор размерности 2 (в данном случае тензор (2, 3))
z = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # "кубик" (3, 3, 3) = тензор размерности 3 (в данном случае (3, 3, 3))
x, y, z
```
Простейшим примером 3-мерного тензора является картинка – это «параллелепипед» из чисел, у коготорого три размерности – высота, ширина и количество каналов, значит это тензор размерности 3. Понятие тензора нужно понимать потому, что в PyTorch мы оперируем переменными типа torch.Tensor (FloatTensor, IntTensor, ByteTensor).  
Типы тензоров в PyTorch:
```py
torch.HalfTensor    # 16 бит, с плавающей точкой
torch.FloatTensor   # 32 бита, с плавающей точкой
torch.DoubleTensor  # 64 бита, с плавающей точкой

torch.ShortTensor   # 16 бит, целочисленный, знаковый
torch.IntTensor     # 32 бита, целочисленный, знаковый
torch.LongTensor    # 64 бита, целочисленный, знаковый

torch.ByteTensor    # 8 бит, целочисленный, беззнаковый
torch.CharTensor    # 8 бит, целочисленный, знаковый
```
Рассмотрим простейшие операции создания, манипулирования тензорами:  
Создание тензора:  
```py
a = torch.FloatTensor([1, 2])
a, a.shape

b = torch.FloatTensor([[1, 2, 3], [4, 5, 6]])
b, b.shape

x = torch.FloatTensor(2, 3, 4)
x, x.shape

x = torch.FloatTensor(100)
x, x.shape

x = torch.IntTensor(45, 57, 14, 2)
x.shape
```
Следует обратить внимание, что при создании тензора через указание размерности, он запоняется неопределенными значениями. Для заполнения тензора нулями необходимо вызвать метод zero_( ):
```py
x = torch.IntTensor(3, 2, 4).zero_()
x
```
Изменение размера тензора (аналог np.reshape( )). Метод torch.view() создаёт новый тензор, а не изменяет старый.
```py
b.view(3, 2)
```
В библиотеке реализованы возможности по смене типа тензора:
```py
a = torch.FloatTensor([1.5, 3.2, -7])
a.type_as(torch.IntTensor())

a.type_as(torch.ByteTensor())
```
Следует учитывать, что при .type_as() создаётся новый тензор (старый не меняется), то есть это не in-place операция.  
Индексация в PyTorch аналогична NumPy:
```py
a = torch.FloatTensor([[100, 20, 35], [15, 184, 11], [12, 11, 555]])
a[0, 0], a[0][1]
```
Арифметика и булевы операции работают также, как и в NumPy, но лучше использовать не опреаторы +, -, *, /, а их аналоги
```py
+ -> torch.add()
- -> torch.sub()
* -> torch.mul()
/ -> torch.div()
```
## Practical
