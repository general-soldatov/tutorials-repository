# LAB 5 "РАЗРАБОТКА ЧАТ-БОТА НА ОСНОВЕ БИБЛИОТЕК ДЛЯ ОБРАБОТКИ ЕСТЕСТВЕННОГО ЯЗЫКА"

## Target
овладеть навыками разработки чат-бота с использованием библиотек для обработки естественного языка (NLTK, re и др.).

## Theory
Обработка естественного языка (NLP) – это область искусственного интеллекта и лингвистики, которая занимается анализом, пониманием и созданием человеческого языка с помощью компьютеров. Python является одним из наиболее популярных языков программирования для работы с NLP благодаря обширному набору библиотек.
Обработка естественного языка становится все более значимой, поскольку она находит применение в различных сферах, таких как:  
*	автоматический перевод;  
*	извлечение информации;  
*	создание вопросно-ответных систем и многое другое.

Точное понимание текста, извлечение скрытых смыслов и генерация «человекопонимаемого» контента возможны только при наличии у разработчиков глубоких знаний инструментов машинной обработки естественного языка.

## Practics
В новом блокноте создайте текстовую ячейку и впишите следующий текст: «Лабораторная работа студента группы … Фамилия Имя», указав свой номер группы, фамилию и имя.  
Наиболее популярной библиотекой с богатым инструментарием для обработки естественного языка считается библиотека Natural Language Toolkit (NLTK). Установите библиотеку Natural Language Toolkit (NLTK) и загрузите необходимые модули.
```python
!pip install nltk
```
```py
import nltk
from nltk.tokenize import word_tokenize

# загрузка модуля punkt
nltk.download('punkt')
```
Используйте функцию word_tokenize для разбивки предложения на слова.  
```py
# токенизируем предложение
text = input('To tokenize: ')
word_tokens = word_tokenize(text)
print('After tokenize:', word_tokens)
```
Функция edit_distance сравнивает две строки и подсчитывает количество символов, в которых они отличаются.   
Общение пользователя с чат-ботом предполагает, что человек может варьировать отдельные слова в вопросе, сохраняя его общий смысл. Кроме того, пользователь может допускать ошибки при написании отдельных слов, поэтому разработчик чат-бота должен предусмотреть определенную степень гибкости в распознавании формулировок, задаваемых пользователем.  
После ввода вопроса пользователем необходимо сравнить его с вопросом, заданным в программном коде.   Если различия между ними незначительны, вопрос пользователя может быть идентифицирован как синоним программного вопроса.  
Для сравнения вопросов используйте функцию edit_distance(text1, text2), где text1 – это вопрос, заданный пользователем, а text2 – это вопрос, прописанный в коде (например, «Какая сейчас погода?»).  
Загрузите функцию edit_distance из библиотеки NLTK для сравнения строк.
```py
text_1 = input("Write your question: ")
reference_question = "Какая сейчас погода?"
distance = nltk.edit_distance(text_1, reference_question)
print('The questions differ by', distance, 'characters')
```
Подсчитывать абсолютное количество различий между символами в двух строках без учета их длины не совсем корректно. Чем длиннее строки, тем больше допустимых различий между ними.  
Функция get_rank(text1) должна вычислять процент несовпадающих символов относительно средней длины этих строк.
```py
def get_rank(text):
    reference_question = "Какая сейчас погода?"
    distance = nltk.edit_distance(text_1, reference_question)
    average_length = (len(text) + len((reference_question))) / 2
    return distance / average_length * 100

text_1 = input("Write your question: ")
print('The difference are', get_rank(text_1), '%')
```
Установите процентное различие между вопросом пользователя и заранее заданным вопросом, например, на уровне 40 %. Если различие между ними составляет меньше указанного процента, программа распознает вопрос пользователя как синонимичный программному. В противном случае вопрос пользователя не будет распознан.  
```py
if get_rank(text_1) < 40:
  print('The difference is less than 40%, so the text is idetified.')
elif get_rank(text_1) < 100:
  print('The difference is over than 40%, so the text is undefined.')
else:
  print('The texts are completely different.')
```
Регулярные выражения позволяют искать, заменять и разбивать текст на основе шаблонов. Одна из наиболее популярных функций модуля re – функция search(), которая используется для поиска шаблона в строке. Если совпадение найдено, функция возвращает объект совпадения, иначе – None.  
Найдите слово «погода» в тексте с помощью функции search().  
```py
# найдем шаблон в строке текста
import re
text = input('Question: ')
pattern = 'погода'
search_text = re.search(pattern, text)
if search_text:
    print('A match has been found:', search_text.group())
else:
    print('No match found')
```
Функция lower() преобразует прописные буквы в строчные. Это полезно, так как пользователь может вводить текст в произвольном регистре. 
```py
upper_text = input('Enter the upper text: ')
lower_text = upper_text.lower()
print('Converted text:', lower_text)
```
Функция sub() может использоваться для удаления знаков препинания. Она ищет в тексте string шаблон pattern, который нужно найти, и заменяет его на выражение repl.  
При общении с чат-ботом пользователь может вводить вопросы, содержащие знаки препинания. Эти знаки не влияют на смысл вопроса, по- этому их необходимо исключить из текста перед обработкой.
Для исключения знаков препинания создайте шаблон, включающий все такие символы: punctuation = r"[^\w\s]", где:  
–	^ – обозначает отрицание последовательности в шаблоне;  
–	\ – указывает, что следующий символ является специальным в регулярном выражении;  
–	\w – соответствует всем буквам, цифрам и символу подчеркивания;  
–	\s – соответствует любым пробельным символам;  
–	^\w\s – исключает любые символы, которые не являются буквами, цифрами, символом подчеркивания или пробелами.  

Исключите все знаки препинания в вопросе пользователя.
```py
import re
text = input('Question: ')
pattern = r"[^\w\s]"
print(re.sub(pattern, '', text))
```
